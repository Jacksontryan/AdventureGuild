package project.Map;

import java.util.ArrayList;
import java.util.Stack;

public class Map2 {

    //grid of floating point values that determine if cell is land or water
    private double[][] grid;

    //grid with map of land, water, cities ect
    private char[][] map;

    //array list of all points of the coast
    private ArrayList<Point> coast;

    //Array list of cities
    private ArrayList<City> cities;

    //array list of islands
    private ArrayList<Island> islands;

    //array list of water regions
    private ArrayList<WaterRegion> waterRegions;


    //threshold which determines if cell is land or not. Greater than threshold is land, less than or equal is water
    private double threshold;

    public Map2(int width, int height, double threshold){

        //instantiate grid to the set size
        this.grid = new double[width][height];

        //set cities to new array list
        this.cities = new ArrayList<City>();

        //set threshold
        this.threshold = threshold;

        //for each point in the grid, set the value of the grid to some value between 0 and 1 inclusive
        for(int i = 0; i < width; i++){
            for(int j = 0; j < height; j++){
                this.grid[i][j] = Math.random();
            }
        }

        //instantiate map variable
        instantiateMap();

    }

    private void instantiateMap(){

        //width of map
        int width = this.grid.length;

        //height of map
        int height = this.grid[0].length;

        //middle x position of map
        double middleX = width / 2.0;

        //middle y position of map
        double middleY = height / 2.0;

        //new Point created in middle of map
        Point middle = new Point(middleX, middleY);

        //blank map created
        map = new char[width][height];

        //for each position on map going from left to right first, then up down
        for(int i = 0; i < width; i++){
            for(int j = 0; j < height; j++){

                //Find distance of position (i,j) normalized from a grid centered on (0,0) in a grid from (-1,1) both horizontally and vertically

                double newX = (i - middleX) / middleX;
                double newY = (j - middleY) / middleY;

                double distanceFromMiddleX = new Point(0,0).distance(new Point(newX, newY));

                //create falloff. More falloff == bigger continent
                double falloff = Math.pow(distanceFromMiddleX, 2);//<-- Experiment with making bigger and smaller continents with falloff variable

                //Get a raw value that determines if position (i,j) is land or water based on the determined threshold
                double value = grid[i][j] - falloff;//<-- Experiment with doing away with the value variable and assigning grid[i][j] to grid[i][j] - falloff to reuse the value later

                if(value <= threshold){
                    map[i][j] = 'w';
                }else{
                    map[i][j] = 'l';
                }

            }

        }

        //if cities have been created, add them to the map
        instantiateCities();

        //find all islands
        getIslands();

        //find all water regions
        getWaterRegions();

        //fill all islands to get one single continent. These last two lines can be swapped to make continents bigger or smaller
        fillAllIslands();

        //fill all water regions to get one single ocean
        fillAllWaterRegions();

        addHeightMap();

        //instantiate the coast
        instantiateCoast();

    }

    private void instantiateCoast(){
        coast = new ArrayList<Point>();
        for(int i = 0; i < map.length; i++){
            for(int j = 0; j < map[0].length; j++){
                if(map[i][j] == 'l' && !new Point(i, j).getWaterNeighbors().isEmpty()){
                    coast.add(new Point(i, j));
                }
            }
        }
    }

    private void addHeightMap(){
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j < grid[0].length; j++){
                if(map[i][j] == 'w'){
                    grid[i][j] = Math.random() * .3;
                }else if(map[i][j] == 'l'){
                    grid[i][j] = Math.random() * .7 + .3;
                }
            }
        }
    }

    private void instantiateCities(){

        //for each city in array cities
        for (City city : this.cities) {

            //get all points the city supposedly occupies
            ArrayList<Point> points = city.getPoints();

            //create a list of all points not occupied by city
            ArrayList<Point> markForDeletion = new ArrayList<Point>();

            //for each point the city supposedly occupies
            for (Point point : points) {

                //if is land -> mark as city land, else -> mark for deletion
                if (map[(int) point.x][(int) point.y] == 'l') {
                    map[(int) point.x][(int) point.y] = 'c';
                } else {
                    markForDeletion.add(point);
                }
            }

            //delete unwanted points
            points.removeAll(markForDeletion);

        }
    }

    private void getIslands(){

        //find width and height
        int width = this.grid.length;
        int height = this.grid[0].length;

        //create a grid of visited points
        boolean[][] visited =  new boolean[width][height];

        //create island array list
        islands = new ArrayList<Island>();

        //for each point (i,j) in the grid
        for(int i = 0; i < width; i++){
            for(int j = 0; j < height; j++){

                //if (i,j) has not been visited and is land
                if(!visited[i][j] && map[i][j] == 'l'){

                    //create array list of points in the island
                    ArrayList<Point> points = new ArrayList<Point>();

                    //create stack of points needed to travel to
                    Stack<Point> pointsToTravel = new Stack<Point>();

                    //create two arrays of all points surrounding (i,j) to the left, right, up and down
                    int[] xTraversal = {-1,0,0,1};
                    int[] yTraversal = {0,-1,1,0};

                    //add point (i,j) to points to travel stack
                    pointsToTravel.push(new Point(i,j));

                    //repeat while points to travel stack is empty
                    while(!pointsToTravel.isEmpty()){

                        //pop the top point, get x and y coordinate
                        Point point = pointsToTravel.pop();
                        int x = point.getX();
                        int y = point.getY();

                        //if visited (x,y) and (x,y) is land
                        if(!visited[x][y] && map[x][y] == 'l'){

                            //set visited[x][y] to true
                            visited[x][y] = true;

                            //add point to points array list
                            points.add(point);

                            //for each point in the two directional traversal arrays
                            for(int k = 0; k < 4; k++){

                                //add each point to each side to the stack
                                pointsToTravel.push(new Point(x + xTraversal[k], y +  yTraversal[k]));
                            }
                        }
                    }

                    //create a new island in the island arrays and set its points array to the one set earlier
                    islands.add(new Island(points));
                }
            }
        }
    }

    private void getWaterRegions(){

        //get width and height of grid
        int width = this.grid.length;
        int height = this.grid[0].length;

        //create a grid of visited points
        boolean[][] visited =  new boolean[width][height];

        //instantiate the water region variable
        waterRegions = new ArrayList<WaterRegion>();

        //for each point in the grid
        for(int i = 0; i < width; i++){
            for(int j = 0; j < height; j++){

                //if point (i,j) has not been visited and is water
                if(!visited[i][j] && map[i][j] == 'w'){

                    //create a new array list of points in the water region
                    ArrayList<Point> points = new ArrayList<Point>();

                    //create a stack of points yet to be traveled to
                    Stack<Point> pointsToTravel = new Stack<Point>();

                    //push (i,j) to points to be traveled to
                    pointsToTravel.push(new Point(i,j));

                    //while points to travel to has points
                    while(!pointsToTravel.isEmpty()){

                        //pop the top point
                        Point point = pointsToTravel.pop();
                        int x = point.getX();
                        int y = point.getY();

                        //if you have not visited point (x,y) and that point on the map is water
                        if(!visited[x][y] && map[x][y] == 'w'){

                            //set that you have visited point (x,y), add point to points
                            visited[x][y] = true;
                            points.add(point);

                            //only push the points on the appropriate sides of each point.
                            // Ex, if at point (0,0), at the top left, there would be no need for the point above or left of it, as they do not exist
                            if(x == 0){
                                pointsToTravel.push(new Point(x + 1, y));
                            }else if(x == width - 1){
                                pointsToTravel.push(new Point(x - 1, y));
                            }else{
                                pointsToTravel.push(new Point(x - 1, y));
                                pointsToTravel.push(new Point(x + 1, y));
                            }

                            if(y == 0){
                                pointsToTravel.push(new Point(x, y + 1));
                            }else if(y == height - 1){
                                pointsToTravel.push(new Point(x, y - 1));
                            }else{
                                pointsToTravel.push(new Point(x, y - 1));
                                pointsToTravel.push(new Point(x, y + 1));
                            }
                        }
                    }

                    //add a new water region composed of the array list of points to the list of water region
                    waterRegions.add(new WaterRegion(points));
                }
            }
        }
    }

    private void fillAllIslands(){

        //set the largest size to 0, and set a largestIsland to null
        int largest = 0;
        Island largestIsland = null;

        //for each island in islands
        for(Island island : islands){

            //the size of the island is greater than the current largest island
            if(island.getSize() > largest){

                //set the largest size to the island size and largestIsland to the current island
                largest = island.getSize();
                largestIsland = island;

            }
        }

        //for each island in islands
        for(Island island : islands){

            //if current island size is not the largest, fill island
            if(!(island.getSize() == largest)){

                island.fillIsland();

            }
        }

        //remove filled islands
        getIslands();

        //reinstate the water regions
        getWaterRegions();
    }

    private void fillAllWaterRegions(){

        //set largest to 0, and the largest water region to null
        int largest = 0;
        WaterRegion largestWaterRegion = null;

        //for each water region in water regions
        for(WaterRegion w : waterRegions){

            //if the size of current water region is greater than largest, set the largest size to the current size and largest water region to current water region
            if(w.getSize() > largest){
                largest = w.getSize();
                largestWaterRegion = w;
            }
        }

        //for each water region in water regions, if water region size is not the largest size, fill the water region
        for(WaterRegion w : waterRegions){
            if(!(w.getSize() == largest)){
                w.fillWaterRegion();
            }
        }

        //remove all filled water region
        getWaterRegions();

        //redraw the islands
        getIslands();
    }

    public int getLeftMostCoordinate(){
        int width = map.length;
        int height = map[0].length;

        int leftmost = width;

        for(int x = 0; x < leftmost; x++){
            for(int y = 0; y < height; y++){
                if(map[x][y] == 'l'){
                    leftmost = x;
                }
            }
        }

        return leftmost;
    }

    public int getRightMostCoordinate(){
        int width = map.length;
        int height = map[0].length;

        int rightmost = 0;

        for(int x = width - 1; x >= rightmost; x--){
            for(int y = 0; y < height; y++){
                if(map[x][y] == 'l'){
                    rightmost = x;
                }
            }
        }

        return rightmost;
    }

    public int getTopMostCoordinate(){
        int width = map.length;
        int height = map[0].length;
        int topmost = height;
        for(int x = 0; x < width; x++){
            for(int y = 0; y < topmost; y++){
                if(map[x][y] == 'l'){
                    topmost = y;
                }
            }
        }

        return topmost;
    }

    public int getBottomMostCoordinate(){
        int width = map.length;
        int height = map[0].length;
        int bottommost = 0;
        for(int x = 0; x < width; x++){
            for(int y = height - 1; y >= bottommost; y--){
                if(map[x][y] == 'l'){
                    bottommost = y;
                }
            }
        }
        return bottommost;
    }

    public void trimMap() {
        int left = getLeftMostCoordinate() - 50;
        int right = getRightMostCoordinate() + 50;
        int top = getTopMostCoordinate() - 50;
        int bottom = getBottomMostCoordinate() + 50;

        int newWidth = right - left + 1;
        int newHeight = bottom - top + 1;

        char[][] temp = new char[newWidth][newHeight];
        double[][] temp2 = new double[newWidth][newHeight];

        for (int x = 0; x < newWidth; x++) {
            for (int y = 0; y < newHeight; y++) {
                temp[x][y] = map[left + x][top + y];
                temp2[x][y] = grid[left + x][top + y];
            }
        }

        map = temp;
        instantiateCoast();
    }

    public char[][] getMap(){
        return map;
    }

    public double getThreshold(){
        return threshold;
    }

    public void setThreshold(double threshold){
        this.threshold = threshold;
    }

    public ArrayList<City> getCities(){
        return cities;
    }

    public ArrayList<WaterRegion> getAllWaterRegions(){
        return waterRegions;
    }

    public ArrayList<Island> getAllIslands(){
        return islands;
    }

    public ArrayList<Point> getCoast(){
        return coast;
    }

    public class Point{

        //x and y coordinates
        private final double x;
        private final double y;

        public Point(double x, double y){
            this.x = x;
            this.y = y;
        }

        //get x position as a double value
        public double getTrueX(){
            return this.x;
        }

        //get y position as a double value
        public double getTrueY(){
            return this.y;
        }

        //get y value as an int value
        public int getY(){
            return (int) this.y;
        }

        //get x value as an int value
        public int getX(){
            return (int) this.x;
        }

        //distance formula
        public double distance(Point p){
            return Math.sqrt(Math.pow(this.x - p.x, 2) + Math.pow(this.y - p.y, 2));
        }

        //Array List of all points next to this point
        public ArrayList<Point> getNeighbors(){

            ArrayList<Point> neighbors = new ArrayList<Point>();

            if(!(x == 0)){
                neighbors.add(new Point(x-1, y));
            }if(!(x == Map2.this.grid.length - 1)){
                neighbors.add(new Point(x+1, y));
            }if(!(y == 0)){
                neighbors.add(new Point(x, y-1));
            }if(!(y == Map2.this.grid[0].length - 1)){
                neighbors.add(new Point(x, y+1));
            }

            return neighbors;
        }

        //returns array list of points of all land neighbors
        public ArrayList<Point> getLandNeighbors(){
            ArrayList<Point> neighbors = getNeighbors();
            ArrayList<Point> landNeighbors = new ArrayList<Point>();

            for (Point neighbor : neighbors) {
                if (Map2.this.map[(int) neighbor.getX()][(int) neighbor.getY()] == 'l' || Map2.this.map[(int) neighbor.getX()][(int) neighbor.getY()] == 'c') {
                    landNeighbors.add(neighbor);
                }
            }

            return landNeighbors;
        }

        //returns array list of points of all water neighbors
        public ArrayList<Point> getWaterNeighbors() {
            ArrayList<Point> neighbors = getNeighbors();
            ArrayList<Point> waterNeighbors = new ArrayList<Point>();

            for (Point neighbor : neighbors) {
                if (Map2.this.map[(int) neighbor.getX()][(int) neighbor.getY()] == 'w') {
                    waterNeighbors.add(neighbor);
                }
            }
            return waterNeighbors;
        }

    }

    public class Location {

        ArrayList<Point> points;

        public Location(ArrayList<Point> points) {
            this.points = points;
        }

        public ArrayList<Point> getPoints() {
            return points;
        }

        public ArrayList<Point> getNeighbors() {
            ArrayList<Point> neighbors = new ArrayList<>();

            for (Point p : points) {
                for (Point n : p.getNeighbors()) {
                    if (!points.contains(n) && !neighbors.contains(n)) {
                        neighbors.add(n);
                    }
                }
            }
            return neighbors;
        }

        public boolean touchesTop(){
            for (Point p : points) {
                if (p.getY() == 0) return true;
            }
            return false;
        }

        public boolean touchesBottom(){
            for (Point p : points) {
                if (p.getY() == Map2.this.map[0].length - 1) return true;
            }
            return false;
        }

        public boolean touchesLeft(){
            for (Point p : points) {
                if (p.getX() == 0) return true;
            }
            return false;
        }

        public boolean touchesRight(){
            for (Point p : points) {
                if (p.getX() == Map2.this.map[0].length - 1) return true;
            }
            return false;
        }
    }

    public class City extends Location{

        private String name;

        private final Point center;

        public City(String name, Point center){
            super(new ArrayList<Point>());
            this.center = center;
            points.add(center);
        }

        public City(String name, Point center, ArrayList<Point> points){
            super(points);
            this.center = center;
        }

        public String getName(){
            return name;
        }

        public Point getCenter(){
            return this.center;
        }

        public String toString(){
            StringBuilder str = new StringBuilder();
            for (Point point : points) {
                str.append(point.toString()).append(" ");
            }
            return str.toString();
        }

    }

    public class Island extends Location{

        public Island(ArrayList<Point> points){
            super(points);
        }

        public int getSize(){
            return super.points.size();
        }

        public void fillIsland(){
            for (Point point : this.points) {
                grid[(int) point.x][(int) point.y] = threshold - 1;
                map[(int) point.x][(int) point.y] = 'w';
            }
        }

    }

    public class WaterRegion extends Location {

        public WaterRegion(ArrayList<Point> points){
            super(points);
        }

        public int getSize(){
            return super.points.size();
        }

        public void fillWaterRegion(){
            for (Point point : this.points) {
                grid[(int) point.x][(int) point.y] = threshold + 1;
                map[(int) point.x][(int) point.y] = 'l';
            }
        }

    }

}
